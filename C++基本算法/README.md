#### BFS：
1. `BFS`的实现。

#### DFS：
1. `DFS`的实现。

#### list_1：
1. 尾插法构建链表。
2. 按值删除元素。
3. 讨论了被调函数中内存空间的生命周期。

#### list_2：
1. 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
2. `listReverse()`。
3. `#include<stack>`头文件下的各种栈操作，定义，出栈，入栈，返回栈顶，判断是否为空，元素数。

#### list_3：
1. 题目：用两个栈实现队列。
2. 类模板`template <typename T> class`的使用实例。
3. `exit()`。
4. `#include<stack>`的使用实例。

#### string_1：
1. `#include<string>`头文件下的`string`类型、常用函数、遍历。
2. `cin`和`getline()`。

#### string_2：
1. `#include<cstring>`头文件下的赋值、复制、连接、比较、长度函数。
2. 字符串的'\0'问题。

#### string_3：
1. 三种字符串定义方式的比较，包括赋值、长度获取（包括数组长度的获取方法）。
2. `string`类型变量 与 `char []`变量 之间的转换。
3. `atoi()`函数、`c_str()`函数。

#### string_4：
1. `char *` 、`char []` 、`string` 三者的类型兼容问题。

#### string_5：
1. `sizeof()`。
2. 当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。

#### string_6：
1. `char * ch = "const";` 和 `string str = "const";`中`ch`和`str`指针内容的问题。
2. `char * ch` 中`ch`所指空间的赋值问题。

#### string_7：
1. 题目：实现一个函数，把字符串中的每个空格替换成`"%20"`。例如输入`“We are happy.”`，则输出`“We%20are%20happy.”`。
2. 代码分析：
```javascript
string str;
getline(cin , str);
char * arr = new char[str.size()+1];
strcpy(arr,str.c_str());
place(arr,str.size()+1);
```

#### tree_1：
1. 二叉树的前序、中序、后序遍历，层次遍历。
2. `#include<queue>`头文件下的队列操作，入队、出队、长度、队首、队尾、判断是否为空。

#### tree_2：
1. 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
2. 根据先序遍历、中序遍历重建二叉树。
3. 对`string_5：2`的补充：即使形参是`arr[]`，`arr`也是指针类型，而非数组指针，即`sizeof(arr)=8`。

#### tree_3：
1. 题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，
还有一个指向父结点的指针。
2. 输出一个节点在中序遍历时的下一节点。
3. 在`tree_2：2`的基础上，使每个节点加入了父指针。

#### 一维数组：
1. 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，
也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组`{2, 3, 1, 0, 2, 5, 3}`，
那么对应的输出是重复的数字2或者3。
2. 原地Hash。

#### 二分查找_1：
1. 二分查找代码

#### 二分查找_2：
1. 题目：一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。（重要）

#### 二维数组_1：
1. 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，
输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
2. 二维数组操作规律简述。

#### 二维数组_2：
1. 赋值方式、形实参数传递。

#### 二维数组_3：
1. 构建动态二维数组。

#### 位运算：
1. 题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。
2. 5种位运算总结。

#### 动态规划：
1. 题目：给你一根长度为`n`绳子，请把绳子剪成`m`段（`m、n`都是整数，`n>1`并且`m≥1`）。每段的绳子的长度记为
`k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]`可能的最大乘积是多少？（每段长也是整数）例如当绳子的长度是`8`时，
我们把它剪成长度分别为`2、3、3`的三段，此时得到最大的乘积`18`。
2. 动态规划基本思想。
3. 注意和贪婪算法的关系。
4. 动态规划也是求解二维数组（矩阵）上路径问题的一个方法。

#### 回溯法：
1. 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开
始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例
如在下面的`3×4`的矩阵中包含一条字符串`“bfce”`的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串`“abfb”`的路径，因
为字符串的第一个字符`b`占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
```javascript
A B T G
C F C S
J D E H
```
2. 对象封装的一些讨论。`struct`对象实例。
3. 要判断`stack.size()`是否能作`for`循环的条件，如`for(;i < stack.size();){stack.push or stack.pop()}`就是错的。
4. 二维数组（矩阵）上的路径问题，要考虑到回溯法。

#### 快速排序：
1. 快排代码。

#### 运算符重载_1：
1. 运算符重载实例。

#### 运算符重载_2：
1. =运算符重载函数。
2. 运算符重载函数的注意点。
3. 对象的封闭性。
4. `delete`使用时的一个注意点。

#### 递归与循环：
1. `Fibonacci`数列的递归、循环实现。
2. 两种方法的性能讨论。