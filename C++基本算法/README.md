#### BFS：
1. `BFS`的实现。

#### DFS：
1. `DFS`的实现。

#### list_1：
1. 尾插法构建链表。
2. 按值删除元素。
3. 讨论了被调函数中内存空间的生命周期。

#### list_2：
1. 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
2. `listReverse()`。
3. `#include<stack>`头文件下的各种栈操作，定义，出栈，入栈，返回栈顶，判断是否为空，元素数。

#### list_3：
1. 题目：用两个栈实现队列。
2. 类模板`template <typename T> class`的使用实例。
3. `exit()`。
4. `#include<stack>`的使用实例。

#### list_4：
1. 题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。
2. 时间复杂度为`O(1)`的按指针删除链表元素。

#### list_5：
1. 题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，
从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。

#### list_6：
1. 题目：一个链表中包含环，如何找出环的入口结点？（注意）

#### list_7：
1. 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。
2. 面试时，要问面试官是否允许头结点存在。若不允许，就得考虑`L=nullptr`的情况。同时，相关的方法，例如尾加法、按值删元法等都需要重写。（重要）

#### list_8：
1. 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。
2. 还是注意头结点是否存在的问题。

#### pow：
1. 题目：实现函数`double Power(double base, int exponent)`，求`base`的`exponent`次方。不得使用库函数，同时不需要考虑大数问题。
2. 实现了`pow(a , b) = a^b`。
3. 讨论了位运算符对提高效率的重要性，并提供了实例。能用位运算的地方就要尽量用，可以大幅提高效率。
4. 异常处理实例。

#### string_1：
1. `#include<string>`头文件下的`string`类型、常用函数、遍历。
2. `cin`和`getline()`。

#### string_2：
1. `#include<cstring>`头文件下的赋值、复制、连接、比较、长度函数。
2. 字符串的'\0'问题。

#### string_3：
1. 三种字符串定义方式的比较，包括赋值、长度获取（包括数组长度的获取方法）。
2. `string`类型变量 与 `char []`变量 之间的转换。
3. `atoi()`函数、`c_str()`函数。

#### string_4：
1. `char *` 、`char []` 、`string` 三者的类型兼容问题。

#### string_5：
1. `sizeof()`。
2. 当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。

#### string_6：
1. `char * ch = "const";` 和 `string str = "const";`中`ch`和`str`指针内容的问题。
2. `char * ch` 中`ch`所指空间的赋值问题。

#### string_7：
1. 题目：实现一个函数，把字符串中的每个空格替换成`"%20"`。例如输入`“We are happy.”`，则输出`“We%20are%20happy.”`。
2. 代码分析：
```javascript
string str;
getline(cin , str);
char * arr = new char[str.size()+1];
strcpy(arr,str.c_str());
place(arr,str.size()+1);
```

#### tree_1：
1. 二叉树的前序、中序、后序遍历，层次遍历。
2. `#include<queue>`头文件下的队列操作，入队、出队、长度、队首、队尾、判断是否为空。

#### tree_2：
1. 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
2. 根据先序遍历、中序遍历重建二叉树。
3. 对`string_5：2`的补充：即使形参是`arr[]`，`arr`也是指针类型，而非数组指针，即`sizeof(arr)=8`。

#### tree_3：
1. 题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，
还有一个指向父结点的指针。
2. 输出一个节点在中序遍历时的下一节点。
3. 在`tree_2：2`的基础上，使每个节点加入了父指针。

#### tree_4：
1. 题目：输入两棵二叉树`A`和`B`，判断`B`是不是`A`的子结构。

#### tree_5：
1. 题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。

#### tree_6：
1. 题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
2. 通过 左根右遍历 和 右根左遍历 的思路解决对称问题。

#### vector:
1. `vector`语法汇总。

#### 一维数组：
1. 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，
也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组`{2, 3, 1, 0, 2, 5, 3}`，
那么对应的输出是重复的数字2或者3。
2. 原地Hash。

#### 二分查找_1：
1. 二分查找代码

#### 二分查找_2：
1. 题目：一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。（重要）

#### 二维数组_1：
1. 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，
输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
2. 二维数组操作规律简述。

#### 二维数组_2：
1. 赋值方式、形实参数传递。

#### 二维数组_3：
1. 构建动态二维数组。

#### 二维数组_4：
1. 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
2. `malloc` 和 `free` ；`new` 和 `delete`。（重要）
3. 创建、回收动态二维数组。模板：
```javascript
T * * arr = new T * [rowNum];
T * arr_ptr = new T[rowNum * colNum]; //构建第一维指针数组 
for (int i = 0; i < rowNum * colNum; ++i)
	if (i % colNum == 0) arr[i / colNum] = &arr_ptr[i]; //为第一维指针数组赋值 
for (int i = 0; i < rowNum; ++i)
	for (int j = 0; j < colNum; ++j)
		arr[i][j] = val_i_j; //为元素赋值
fun(arr); //使用
delete arr_ptr; //回收第二维空间
delete arr; //回收第一维空间 
```

#### 位运算：
1. 题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。
2. 5种位运算总结。

#### 动态规划：
1. 题目：给你一根长度为`n`绳子，请把绳子剪成`m`段（`m、n`都是整数，`n>1`并且`m≥1`）。每段的绳子的长度记为
`k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]`可能的最大乘积是多少？（每段长也是整数）例如当绳子的长度是`8`时，
我们把它剪成长度分别为`2、3、3`的三段，此时得到最大的乘积`18`。
2. 动态规划基本思想。
3. 注意和贪婪算法的关系。
4. 动态规划也是求解二维数组（矩阵）上路径问题的一个方法。

#### 匹配_1：
1. 题目：请实现一个函数用来匹配包含`'.'`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。

#### 匹配_2：
1. 题目：题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
例如，字符串`“+100”、“5e2”、“-123”、“.1416”`及`“-1E-16”、“3.”`都表示数值，
但`“12e”、 “1a3.14”、“1.2.3”、“+-5”`及`“12e+5.4”，“.e+5”`都不是。
2. 该题目是一道考察代码全面性的经典题。 

#### 回溯法：
1. 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开
始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例
如在下面的`3×4`的矩阵中包含一条字符串`“bfce”`的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串`“abfb”`的路径，因
为字符串的第一个字符`b`占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
```javascript
A B T G
C F C S
J D E H
```
2. 对象封装的一些讨论。`struct`对象实例。
3. 要判断`stack.size()`是否能作`for`循环的条件，如`for(;i < stack.size();){stack.push or stack.pop()}`就是错的。
4. 二维数组（矩阵）上的路径问题，要考虑到回溯法。

#### 大数：
1. 题目：输入数字`n`，按顺序打印出从`1`最大的`n`位十进制数。比如输入`3`，则打印出`1、2、3、4、5`一直到最大的`3`位数即`999`。
2. 注意，本题的解法不能说明大数运算就一定是用`" queue、stack、int arr[] "`作为大数的存储结构。大数的`" + - * / "`等运算，常见的是以字符串为存储结构。
3. 大数使用`struct`进行封装。这是封装的又一实例。
4. 哨兵。（重要）

#### 快速排序：
1. 快排代码。

#### 泛化：
1. 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
2. 泛化代码的实例。

#### 运算符重载_1：
1. 运算符重载实例。

#### 运算符重载_2：
1. =运算符重载函数。
2. 运算符重载函数的注意点。
3. 对象的封闭性。
4. `delete`使用时的一个注意点。

#### 递归与循环：
1. `Fibonacci`数列的递归、循环实现。
2. 两种方法的性能讨论。

#### 杂记
1. 各类型实例在内存中占有的字节数（`bit`位）：
```javascript
#include <iostream>
#include <string>
using namespace std;
int main() {
	cout << sizeof(char) << ends; //1B
	cout << sizeof(short) << ends; //2B
	cout << sizeof(int) << ends; //4B
	cout << sizeof(long) << ends; //4B
	cout << sizeof(long int) << ends; //4B
	cout << sizeof(long long) << ends; //8B
	cout << sizeof(float) << ends; //4B
	cout << sizeof(double) << ends; //8B
	cout << sizeof(int *) << ends; //8B
	cout << sizeof(char *) << ends; //8B
	cout << sizeof(double *) << ends; //8B
	cout << sizeof(string) << ends; //8B
	return 0;
}
```
此外，要注意`double`和`float`变量最后几位是近似位，故类似于`double x = 0.5;if(x == 0.5){}`的语句是错误的，因为实际上`x!=0.5`，而可能是`x=0.5000....01`。
因此，在使用`== 、>=、<=`等带有`=`的判断符时，要设`EPSILON = 1e-7`。当`fabs(x - 0.5)<=EPSILON`时，条件满足。