#### BFS：
1. `BFS`的实现。

#### DFS：
1. `DFS`的实现。

#### list_1：
1. 尾插法构建链表。
2. 按值删除元素。
3. 讨论了被调函数中内存空间的生命周期。

#### list_2：
1. 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
2. `listReverse()`。
3. `#include<stack>`头文件下的各种栈操作，定义，出栈，入栈，返回栈顶，判断是否为空，元素数。

#### list_3：
1. 题目：用两个栈实现队列。
2. 类模板`template <typename T> class`的使用实例。
3. `exit()`。
4. `#include<stack>`的使用实例。

#### list_4：
1. 题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。
2. 时间复杂度为`O(1)`的按指针删除链表元素。

#### list_5：
1. 题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，
从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。

#### list_6：
1. 题目：一个链表中包含环，如何找出环的入口结点？（注意）

#### list_7：
1. 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。
2. 面试时，要问面试官是否允许头结点存在。若不允许，就得考虑`L=nullptr`的情况。同时，相关的方法，例如尾加法、按值删元法等都需要重写。（重要）

#### list_8：
1. 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。
2. 还是注意头结点是否存在的问题。

#### list_9：
1. 题目：请实现函数`ComplexListNode* Clone(ComplexListNode* pHead)`，复制一个复杂链表。在复杂链表中，每个结点除了有一个`m_pNext`指针指向下一个结点外，
还有一个`m_pSibling`指向链表中的任意结点或者`nullptr`。
2. 特殊链表的复制方法。

#### map：
1. `map`语法汇总。`map`内部使用红黑树实现的，在建立映射的过程中会实现按`key`值大小的自动升序。`map`的`key`值是唯一的。

#### multiset：
1. `multiset`语法汇总。`multiset`位于`#include<set>`中，是含重自动升序的集合。

#### pow：
1. 题目：实现函数`double Power(double base, int exponent)`，求`base`的`exponent`次方。不得使用库函数，同时不需要考虑大数问题。
2. 实现了`pow(a , b) = a^b`。
3. 讨论了位运算符对提高效率的重要性，并提供了实例。能用位运算的地方就要尽量用，可以大幅提高效率。
4. 异常处理实例。

#### set：
1. `set`语法汇总。`set`是一个内部不含重复元素且自动有序的集合。

#### stack_1：
1. 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的`min`函数。在该栈中，调用`min、push`及`pop`的时间复杂度都是`O(1)`。（类型题）
2. 模块化、鲁棒性讨论。一个好习惯是：写代码就要写出可被直接调用的模块。要考虑各种输入。而不要把各种方法写的耦合。要保证随便拿出一个方法，就能迁移到别的代码中。
3. `assert(条件语句)`。

#### stack_2：
1. 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列`1、2、3、4、5`
是某栈的压栈序列，序列`4、5、3、2、1`是该压栈序列对应的一个弹出序列，但`4、3、5、1、2`就不可能是该压栈序列的弹出序列。
2. 泛化代码的实例。

#### string_1：
1. `#include<string>`头文件下的`string`类型、常用函数、遍历。
2. `cin`和`getline()`。

#### string_2：
1. `#include<cstring>`头文件下的赋值、复制、连接、比较、长度函数。
2. 字符串的'\0'问题。

#### string_3：
1. 三种字符串定义方式的比较，包括赋值、长度获取（包括数组长度的获取方法）。
2. `string`类型变量 与 `char []`变量 之间的转换。
3. `atoi()`函数、`c_str()`函数。

#### string_4：
1. `char *` 、`char []` 、`string` 三者的类型兼容问题。

#### string_5：
1. `sizeof()`。
2. 当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。

#### string_6：
1. `char * ch = "const";` 和 `string str = "const";`中`ch`和`str`指针内容的问题。
2. `char * ch` 中`ch`所指空间的赋值问题。

#### string_7：
1. 题目：实现一个函数，把字符串中的每个空格替换成`"%20"`。例如输入`“We are happy.”`，则输出`“We%20are%20happy.”`。
2. 代码分析：
```javascript
string str;
getline(cin , str);
char * arr = new char[str.size()+1];
strcpy(arr,str.c_str());
place(arr,str.size()+1);
```

#### tree_1：
1. 二叉树的前序、中序、后序遍历，层次遍历。
2. `#include<queue>`头文件下的队列操作，入队、出队、长度、队首、队尾、判断是否为空。

#### tree_2：
1. 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
2. 根据先序遍历、中序遍历重建二叉树。
3. 对`string_5：2`的补充：即使形参是`arr[]`，`arr`也是指针类型，而非数组指针，即`sizeof(arr)=8`。

#### tree_3：
1. 题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，
还有一个指向父结点的指针。
2. 输出一个节点在中序遍历时的下一节点。
3. 在`tree_2：2`的基础上，使每个节点加入了父指针。

#### tree_4：
1. 题目：输入两棵二叉树`A`和`B`，判断`B`是不是`A`的子结构。

#### tree_5：
1. 题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。

#### tree_6：
1. 题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
2. 通过 左根右遍历 和 右根左遍历 的思路解决对称问题。

#### tree_7：
1. 题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
2. `vector`实例。层次遍历实例。
3. `struct`定义的对象，若写成`root();`或`root(1,2);`则错误，因为`struct`对象只能用成员符访问赋值。这一点不同于类，因为`struct`无构造函数。故：
```javascript
structType s;
s.elem_1 = val_1;
...
s.elem_2 = val_2;
```

#### tree_8：
1. 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。
2. 这种题有固定的说辞：若B是某一A的什么（即存在A与B对应），则怎么怎么。解法就是预设B确实是某一A的什么，然后根据这种对应关系下A要求B满足的性质，去倒推B是否果真如此。
若是，A存在，否则，A不存在。（类型题）

#### tree_9：
1. 题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

#### tree_10：
1. 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### tree_11：
1. 题目：请实现两个函数，分别用来序列化和反序列化二叉树。序列化就是二叉树转链表，反序列化就是链表转二叉树。
2. 树结构随线性结构变化而变化的典型递归思路。

#### vector:
1. `vector`语法汇总。

#### 一维数组：
1. 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，
也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组`{2, 3, 1, 0, 2, 5, 3}`，
那么对应的输出是重复的数字2或者3。
2. 原地Hash。

#### 二分查找_1：
1. 二分查找代码

#### 二分查找_2：
1. 题目：一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。（重要）

#### 二维数组_1：
1. 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，
输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
2. 二维数组操作规律简述。

#### 二维数组_2：
1. 赋值方式、形实参数传递。

#### 二维数组_3：
1. 构建动态二维数组。

#### 二维数组_4：
1. 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
2. `malloc` 和 `free` ；`new` 和 `delete`。（重要）
3. 创建、回收动态二维数组。模板：
```javascript
T * * arr = new T * [rowNum];
T * arr_ptr = new T[rowNum * colNum]; //构建第一维指针数组 
for (int i = 0; i < rowNum * colNum; ++i)
	if (i % colNum == 0) arr[i / colNum] = &arr_ptr[i]; //为第一维指针数组赋值 
for (int i = 0; i < rowNum; ++i)
	for (int j = 0; j < colNum; ++j)
		arr[i][j] = val_i_j; //为元素赋值
fun(arr); //使用
delete arr_ptr; //回收第二维空间
delete arr; //回收第一维空间 
```

#### 位运算：
1. 题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。
2. 5种位运算总结。

#### 动态规划：
1. 题目：给你一根长度为`n`绳子，请把绳子剪成`m`段（`m、n`都是整数，`n>1`并且`m≥1`）。每段的绳子的长度记为
`k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]`可能的最大乘积是多少？（每段长也是整数）例如当绳子的长度是`8`时，
我们把它剪成长度分别为`2、3、3`的三段，此时得到最大的乘积`18`。
2. 动态规划基本思想。
3. 注意和贪婪算法的关系。
4. 动态规划也是求解二维数组（矩阵）上路径问题的一个方法。

#### 匹配_1：
1. 题目：请实现一个函数用来匹配包含`'.'`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。

#### 匹配_2：
1. 题目：题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
例如，字符串`“+100”、“5e2”、“-123”、“.1416”`及`“-1E-16”、“3.”`都表示数值，
但`“12e”、 “1a3.14”、“1.2.3”、“+-5”`及`“12e+5.4”，“.e+5”`都不是。
2. 该题目是一道考察代码全面性的经典题。 

#### 回溯法：
1. 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开
始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例
如在下面的`3×4`的矩阵中包含一条字符串`“bfce”`的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串`“abfb”`的路径，因
为字符串的第一个字符`b`占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
```javascript
A B T G
C F C S
J D E H
```
2. 对象封装的一些讨论。`struct`对象实例。
3. 要判断`stack.size()`是否能作`for`循环的条件，如`for(;i < stack.size();){stack.push or stack.pop()}`就是错的。
4. 二维数组（矩阵）上的路径问题，要考虑到回溯法。

#### 大数：
1. 题目：输入数字`n`，按顺序打印出从`1`最大的`n`位十进制数。比如输入`3`，则打印出`1、2、3、4、5`一直到最大的`3`位数即`999`。
2. 注意，本题的解法不能说明大数运算就一定是用`" queue、stack、int arr[] "`作为大数的存储结构。大数的`" + - * / "`等运算，常见的是以字符串为存储结构。
3. 大数使用`struct`进行封装。这是封装的又一实例。
4. 哨兵。（重要）

#### 大规模数据处理：
1. 题目：输入`n`个整数，找出其中最小的`k`个数。例如输入`4、5、1、6、2、7、3、8`这`8`个数字，则最小的`4`个数字是`1、2、3、4`。
2. `multiset`自调整为大顶堆实例。

#### 快速排序_1：
1. 快排代码。

#### 快速排序_2：
1. 题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为`9`的数组`{1, 2, 3, 2, 2, 2, 5, 4, 2}`。由于数字`2`在数组中
出现了`5`次，超过数组长度的一半，因此输出`2`。
2. 快排的改造思路。

#### 泛化：
1. 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
2. 泛化代码的实例。

#### 运算符重载_1：
1. 运算符重载实例。

#### 运算符重载_2：
1. =运算符重载函数。
2. 运算符重载函数的注意点。
3. 对象的封闭性。
4. `delete`使用时的一个注意点。

#### 递归与循环_1：
1. `Fibonacci`数列的递归、循环实现。
2. 两种方法的性能讨论。
3. 青蛙跳台阶问题：一只青蛙一次可以跳上一级台阶，也可以跳上2级台阶。求该青蛙跳上一个`n`级台阶总共有多少种跳法。

#### 递归与循环_2：
1. 题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串`abc`，则打印出由字符`a、b、c`所能排列出来的所有字符串`abc、acb、bac、bca、cab`和`cba`。
2. 到底什么时候、什么情况下构建这个三明治？这里定义如下：当为了给递归调用传递关系而改变某些数据时，就要考虑是否要在这些数据和递归调用两端构建一个三明治，
以保证这些数据可以不受某次递归的影响，而不受某次递归的影响是"循环套递归结构"求解的基本要求。当然，也有可能出现如`tree_11`中所述的那种要求，即需要递归改变的数据。
这就不需要三明治了，而要使用`&`、指针来传参。
3. 启动函数的重要性。

#### 递归与循环_3：
1. 题目：输入一个含有`8`个数字的数组，判断有没有可能把这`8`个数字分别放到正方体的`8`个顶点上，使得正方体上三组相对的面上的`4`个顶点的和都相等。
2. 八皇后问题：在`8 ×8`的国际象棋盘上摆放`8`个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。问有多少种符合条件的摆法？

#### 杂记
1. 各类型实例在内存中占有的字节数（`bit`位）：
```javascript
#include <iostream>
#include <string>
using namespace std;
int main() {
	cout << sizeof(char) << ends; //1B
	cout << sizeof(short) << ends; //2B
	cout << sizeof(int) << ends; //4B
	cout << sizeof(long) << ends; //4B
	cout << sizeof(long int) << ends; //4B
	cout << sizeof(long long) << ends; //8B
	cout << sizeof(float) << ends; //4B
	cout << sizeof(double) << ends; //8B
	cout << sizeof(int *) << ends; //8B
	cout << sizeof(char *) << ends; //8B
	cout << sizeof(double *) << ends; //8B
	cout << sizeof(string) << ends; //8B
	return 0;
}
```
此外，要注意`double`和`float`变量最后几位是近似位，故类似于`double x = 0.5;if(x == 0.5){}`的语句是错误的，因为实际上`x!=0.5`，而可能是`x=0.5000....01`。
因此，在使用`== 、>=、<=`等带有`=`的判断符时，要设`EPSILON = 1e-7`。当`fabs(x - 0.5)<=EPSILON`时，条件满足。

2. [STL用法](http://c.biancheng.net/stl/)
3. `auto`用法：
```javascript
/*
可以将任何值赋给auto修饰的变量，auto变量一定要初始化。编译器会根据初始化值推断变量类型。 
*/
#include <iostream>
#include <typeinfo>
#include <vector> 
using namespace std;
int main(){
	auto a = 1;
	cout << typeid(a).name() << endl; //i
	
	int b [] = {1,2,3,4};
	auto & c = b;
	cout << typeid(c).name() << endl; //a4_i
	
	auto d = "I love you." , e = "you hate me."; //序列初始化要求变量必须推导为同一类型。 
	cout << typeid(d).name() << endl; //pkc
	
	vector<double> d_v{1.1,2.2,3.3,4.4};
	for(auto f = d_v.begin() ; f != d_v.end() ; ++f);
	
	for(int i : b) cout << i << ends; //遍历序列方式
	cout << endl;
	
	for(auto i : d_v) cout << i << ends;
	
	return 0;
} 
```